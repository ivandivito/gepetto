
.DSEG

SFL: .BYTE 4 ;Saved file lenght

.CSEG

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18
.DEF BUTTON_REG = R19
RUNNING_RUN:
	
	;Procesar buffer GRBL
	
	;Verificar si termina en \n
	POINT_Y_TO_END_OF_BUFFER GRBL_BUFFER, GRBL_BUFFER_POINTER
	
	LD TEMP_1, Y
	
	CPI TEMP_1, '\n'
	BRNE RUNNING_GRBL_CONTINUE
		
		RCALL RUNNING_GRBL_PROCESS_LINE
	
	RUNNING_GRBL_CONTINUE:

	;Si hay cambio de estado terminar
	LDS TEMP_1, CURRENT_STATE
	CPI TEMP_1, STATE_RUNNING
	BRNE RUNNING_END

	;Procesar buffer SD

	LDS GGR_REG, GGR
	ANDI GGR_REG, (1<<GD)
	BRNE RUNNING_SD_CONTINUE

		RCALL RUNNING_SD_PROCESS_LINE

	RUNNING_SD_CONTINUE:

	;Si hay cambio de estado terminar
	LDS TEMP_1, CURRENT_STATE
	CPI TEMP_1, STATE_RUNNING
	BRNE RUNNING_END
	
	LDS GGR_REG, GGR

	CALL BUTTONS_READ
	MOV BUTTON_REG, TEMP_1
	ANDI TEMP_1, (1<<BUTTONS_CHANGE) ; Si es el boton de CONFIRMAR
	BREQ RUNNING_BUTTONS_TST_SELECT
	
		LDI TEMP_1, (1<<UIS)
		EOR GGR_REG, TEMP_1 ;Invertir estado de UI
		LDI TEMP_1, (1<<UII)
		OR GGR_REG, TEMP_1 ;Invalidar UI
		STS GGR, GGR_REG ;Guardar

		RJMP RUNNING_BUTTONS_CONTINUE

	RUNNING_BUTTONS_TST_SELECT:
	MOV TEMP_1, BUTTON_REG
	ANDI TEMP_1, (1<<BUTTONS_SELECT) ; Si es el boton de select
	BREQ RUNNING_BUTTONS_CONTINUE

		MOV TEMP_2, GGR_REG
		ANDI TEMP_2, (1<<UIS) ;Verificar estado
		BREQ RUNNING_CANCEL

			MOV TEMP_2, GGR_REG
			ANDI TEMP_2, (1<<RSS) ;Verificar estado
			BREQ RUNNING_PAUSE

				RCALL RUNNING_CONTINUE_GRBL

				LDI TEMP_1, ~(1<<RSS)
				AND GGR_REG, TEMP_1 ;pasar a estado operando
				LDI TEMP_1, (1<<UII)
				OR GGR_REG, TEMP_1 ;Invalidar UI
				STS GGR, GGR_REG ;Guardar
			
				RJMP RUNNING_BUTTONS_CONTINUE

			RUNNING_PAUSE:
				RCALL RUNNING_PAUSE_GRBL

				LDI TEMP_1, (1<<RSS)
				OR GGR_REG, TEMP_1 ;pasar a estado corriendo
				LDI TEMP_1, (1<<UII)
				OR GGR_REG, TEMP_1 ;Invalidar UI
				STS GGR, GGR_REG ;Guardar

				RJMP RUNNING_BUTTONS_CONTINUE
			
		RUNNING_CANCEL:
			RCALL RUNNING_CANCEL_GRBL

			LDI TEMP_2, STATE_IDLE ;Ir a STATE_CONNECTED
			STS CURRENT_STATE, TEMP_2
			LDI TEMP_1, (1<<UII)
			OR GGR_REG, TEMP_1 ;Invalidar UI
			STS GGR, GGR_REG ;Guardar

			RJMP IDLE_END

	RUNNING_BUTTONS_CONTINUE:

	;Actualizar UI
	LDS TEMP_1, GGR
	ANDI TEMP_1, (1<<UII)
	BREQ RUNNING_END ;Verificar si la interfaz esta invalida
		RCALL RUNNING_REFRESH_UI

	RUNNING_END:

	RET

;Subrutina para procesar una linea de GRBL

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18
RUNNING_GRBL_PROCESS_LINE:

	PUSH XL
	PUSH XH
	PUSH GGR_REG

	LDS GGR_REG, GGR

	LDI XL, LOW(GRBL_BUFFER)
	LDI XH, HIGH(GRBL_BUFFER)

	LDI ZL, LOW(GRBL_OK<<1)
	LDI ZH, HIGH(GRBL_OK<<1)

	CALL STRING_COMPARE_P
	BREQ RUNNING_GRBL_PROCESS_LINE_TST_ERROR
		
		;si llega un ok habilitar el envio de un dato
		ANDI GGR_REG,~(1<<GD)
		STS GGR,GGR_REG
		RJMP RUNNING_GRBL_PROCESS_LINE_END

	RUNNING_GRBL_PROCESS_LINE_TST_ERROR:
	LDI ZL, LOW(GRBL_ERROR<<1)
	LDI ZH, HIGH(GRBL_ERROR<<1)

	CALL STRING_COMPARE_P
	BREQ RUNNING_GRBL_PROCESS_LINE_TST_ALARM

		;si llega un error saltar a error
		LDI TEMP_1, STATE_ERROR
		STS CURRENT_STATE, TEMP_1
		ORI GGR_REG, (1<<UII) ;Invalidar UI
		STS GGR, GGR_REG ;Guardar

	RUNNING_GRBL_PROCESS_LINE_TST_ALARM:
	LDI ZL, LOW(GRBL_ALARM<<1)
	LDI ZH, HIGH(GRBL_ALARM<<1)

	CALL STRING_COMPARE_P
	BREQ RUNNING_GRBL_PROCESS_LINE_END

		;si llega un error saltar a error
		LDI TEMP_1, STATE_ERROR
		STS CURRENT_STATE, TEMP_1
		ORI GGR_REG, (1<<UII) ;Invalidar UI
		STS GGR, GGR_REG ;Guardar
	
	RUNNING_GRBL_PROCESS_LINE_END:
	
	BUFFER_CLEAR GRBL_BUFFER_POINTER

	POP GGR_REG
	POP XH
	POP XL

	RET

;Subrutina para obtener y procesar una linea de la SD

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18
.DEF SFL_REG_0 = R19 ;MS
.DEF SFL_REG_1 = R20
.DEF SFL_REG_2 = R21
.DEF SFL_REG_3 = R22 ;LS
RUNNING_SD_PROCESS_LINE:
	
	PUSH XL
	PUSH XH
	PUSH GGR_REG

	LDS GGR_REG, GGR
	CALL SD_RX_LINE
	
	LDI XL, LOW(SD_BUFFER)
	LDI XH, HIGH(SD_BUFFER)

	LDI ZL, LOW(SD_GEPPETO_SIGNATURE<<1)
	LDI ZH, HIGH(SD_GEPPETO_SIGNATURE<<1)

	CALL STRING_COMPARE_P ; la comparacion de inicio de archivo setea el numero de lineas
	BREQ RUNNING_SD_PROCESS_LINE_CONTINUE

		LDI XL, LOW(SD_BUFFER + SD_GEPPETO_SIGNATURE_LENGHT)
		LDI XH, HIGH(SD_BUFFER + SD_GEPPETO_SIGNATURE_LENGHT)

		LDS SFL_REG_0, SD_BUFFER + SD_GEPPETO_SIGNATURE_LENGHT
		LDS SFL_REG_1, SD_BUFFER + SD_GEPPETO_SIGNATURE_LENGHT + 1
		LDS SFL_REG_2, SD_BUFFER + SD_GEPPETO_SIGNATURE_LENGHT + 2
		LDS SFL_REG_3, SD_BUFFER + SD_GEPPETO_SIGNATURE_LENGHT + 3

		LDS TEMP_1, SD_BUFFER + SD_GEPPETO_SIGNATURE_LENGHT + 4
		CPI TEMP_1, '\n'
		BRNE RUNNING_SD_PROCESS_LINE_END_SAVE
		;si no tiene la estructura esperada ir a error
		LDI TEMP_1, STATE_ERROR
		STS CURRENT_STATE, TEMP_1
		ORI GGR_REG, (1<<UII) ;Invalidar UI
		STS GGR, GGR_REG ;Guardar

		RJMP RUNNING_SD_PROCESS_LINE_END

	RUNNING_SD_PROCESS_LINE_CONTINUE:

	LDS SFL_REG_0, SFL
	LDS SFL_REG_1, SFL + 1
	LDS SFL_REG_2, SFL + 2
	LDS SFL_REG_3, SFL + 3
	
	;si no faltan mas lineas ir a IDLE
	TST SFL_REG_3
	BRNE RUNNING_SD_PROCESS_LINE_SEND
	TST SFL_REG_2
	BRNE RUNNING_SD_PROCESS_LINE_SEND
	TST SFL_REG_1
	BRNE RUNNING_SD_PROCESS_LINE_SEND
	TST SFL_REG_0
	BRNE RUNNING_SD_PROCESS_LINE_SEND

	LDI TEMP_1, STATE_IDLE ;Ir a STATE_CONNECTED
	STS CURRENT_STATE, TEMP_1
	LDI TEMP_1, (1<<UII)
	OR GGR_REG, TEMP_1 ;Invalidar UI
	STS GGR, GGR_REG ;Guardar

	RJMP RUNNING_SD_PROCESS_LINE_END_SAVE
	
	RUNNING_SD_PROCESS_LINE_SEND:

	LDI XL, LOW(SD_BUFFER)
	LDI XH, HIGH(SD_BUFFER)
			
	CALL GRBL_SEND_D_LINE
	
	LDI TEMP_1, 1
	SUB SFL_REG_0, TEMP_1
	SBC SFL_REG_1, ZERO_REG
	SBC SFL_REG_2, ZERO_REG
	SBC SFL_REG_3, ZERO_REG

	RUNNING_SD_PROCESS_LINE_END_SAVE:

	STS SFL, SFL_REG_0
	STS SFL + 1, SFL_REG_1
	STS SFL + 2, SFL_REG_2
	STS SFL + 3 ,SFL_REG_3

	RUNNING_SD_PROCESS_LINE_END:

	POP GGR_REG
	POP XH
	POP XL

	RET

	
;Subrutina para reanudar operacion de GRBL

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18
RUNNING_CONTINUE_GRBL:
	
	PUSH ZL
	PUSH ZH

	LDI ZL, LOW(GRBL_CONTINUE_CMD<<1)
	LDI ZH, HIGH(GRBL_CONTINUE_CMD<<1)
			
	CALL GRBL_SEND_P_LINE

	POP ZH
	POP ZL

	RET

;Subrutina para pausar operacion de GRBL

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18
RUNNING_PAUSE_GRBL:
	
	PUSH ZL
	PUSH ZH

	LDI ZL, LOW(GRBL_PAUSE_CMD<<1)
	LDI ZH, HIGH(GRBL_PAUSE_CMD<<1)
			
	CALL GRBL_SEND_P_LINE

	POP ZH
	POP ZL

	RET

;Subrutina para cancelar operacion de GRBL

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18
RUNNING_CANCEL_GRBL:
	
	PUSH ZL
	PUSH ZH

	LDI ZL, LOW(GRBL_CANCEL_CMD<<1)
	LDI ZH, HIGH(GRBL_CANCEL_CMD<<1)
			
	CALL GRBL_SEND_P_LINE

	POP ZH
	POP ZL

	RET

;Subrutina para actualizar interfaz

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18
RUNNING_REFRESH_UI:
	
	;Procesar botones UIS 0 es pausar (RSS = 0)/reanudar (RSS = 1) y 1 es cancelar

	PUSH GGR_REG
	PUSH ZL
	PUSH ZH

	LDI ZL, LOW(CONSTANT_RUNNING_TITLE<<1)
	LDI ZH, HIGH(CONSTANT_RUNNING_TITLE<<1)
	
	CALL UI_WRITE_FIRST_LINE_P_STRING ;Escribir titulo

	LDS GGR_REG, GGR ;Cargar registro de flags

	MOV TEMP_1, GGR_REG
	ANDI TEMP_1, (1<<UIS) ;Verificar estado de interfaz
	BREQ RUNNING_UI_CANCEL
		
		MOV TEMP_1, GGR_REG
		ANDI TEMP_1, (1<<RSS) ;Verificar subestado de running
		BREQ RUNNING_UI_CONTINUE

			LDI ZL, LOW(CONSTANT_RUNNING_PAUSE<<1)
			LDI ZH, HIGH(CONSTANT_RUNNING_PAUSE<<1)
			CALL UI_WRITE_SECOND_LINE_P_STRING ;Escribir primera linea

			RJMP RUNNING_UI_END

		RUNNING_UI_CONTINUE:
			
			LDI ZL, LOW(CONSTANT_RUNNING_CONTINUE<<1)
			LDI ZH, HIGH(CONSTANT_RUNNING_CONTINUE<<1)
			CALL UI_WRITE_SECOND_LINE_P_STRING ;Escribir primera linea
		
			RJMP RUNNING_UI_END
	RUNNING_UI_CANCEL:

		LDI ZL, LOW(CONSTANT_RUNNING_CANCEL<<1)
		LDI ZH, HIGH(CONSTANT_RUNNING_CANCEL<<1)
		CALL UI_WRITE_SECOND_LINE_P_STRING ;Escribir primera linea
		
	RUNNING_UI_END:

	ANDI GGR_REG, ~(1<<UII) ;Limpiar flag de invalido
	STS GGR, GGR_REG

	POP ZH
	POP ZL
	POP GGR_REG
	RET

