
.CSEG

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17
.DEF GGR_REG = R18

CONNECTED_RUN:
	
	;Procesar buffer GRBL
	
	;Verificar si termina en \n
	POINT_Y_TO_END_OF_BUFFER GRBL_BUFFER, GRBL_BUFFER_POINTER
	
	LD TEMP_1, Y
	
	CPI TEMP_1, '\n'
	BRNE CONNECTED_GRBL_CONTINUE
		
		RCALL CONNECTED_GRBL_PROCESS_LINE
	
	CONNECTED_GRBL_CONTINUE:
	
	;Verificar si hay timeout
	CALL USB_CHECK_TIMEOUT

	BREQ CONNECTED_USB_NO_TIMEOUT
		
		;Setear flag de conecci√≥n
		LDS GGR_REG, GGR
		MOV TEMP, GGR_REG
		ANDI TEMP, ~(1<<UC)
		STS GGR, TEMP
		
		;Ir a IDLE
		LDI TEMP, STATE_IDLE
		STS CURRENT_STATE, TEMP

		ORI GGR_REG, (1<<UII) ;Invalidar UI
		STS GGR, GGR_REG ;Guardar
		
	CONNECTED_USB_NO_TIMEOUT:

	;Si hay cambio de estado terminar
	LDS TEMP_1, CURRENT_STATE
	CPI TEMP_1, STATE_CONNECTED
	BRNE CONNECTED_END
	
	;Procesar buffer USB (guardar o ejecutar)
	
	;Verificar si termina en \n
	POINT_Y_TO_END_OF_BUFFER USB_BUFFER, USB_BUFFER_POINTER
	
	LD TEMP_1, Y
	
	CPI TEMP_1, '\n'
	BRNE CONNECTED_USB_CONTINUE
	
		RCALL CONNECTED_USB_PROCESS_LINE
	
	CONNECTED_USB_CONTINUE:
	
	;Procesar botones
	
	.DEF GGR_REG = R11
	
	CALL BUTTONS_READ
	
	LDS GGR_REG, GGR

	ANDI TEMP_1, (1<<BUTTONS_SELECT) ; Si es el boton de CONFIRMAR
	BREQ CONNECTED_BUTTONS_CONTINUE
	
		LDI TEMP_2, STATE_IDLE ;Ir a STATE_IDLE
		STS CURRENT_STATE, TEMP_2
		LDI TEMP_1, (1<<UII)
		OR GGR_REG, TEMP_1 ;Invalidar UI
		STS GGR, GGR_REG ;Guardar

		RJMP CONNECTED_END

	CONNECTED_BUTTONS_CONTINUE:
	
	;Actualizar UI
	LDS TEMP_1, GGR
	ANDI TEMP_1, (1<<UII)
	BREQ CONNECTED_END ;Verificar si la interfaz esta invalida
		RCALL CONNECTED_REFRESH_UI
	CONNECTED_END:
	
	RET

	
;Subrutina para procesar una linea de GRBL
;Que hacer cuando hay un error aca? enviar a la PC? Cancelar coneccion? Ir a STATE_ERROR?

.DEF TEMP_1 = R16
.DEF TEMP_2 = R17

CONNECTED_GRBL_PROCESS_LINE:
	
	LDS TEMP_1, GGR
	ANDI TEMP_1, (1<<CSS) ;Verificar sub estado
	BRNE CONNECTED_GRBL_SAVING
	
		PUSH XL
		PUSH XH
		
		LDI XL, LOW(GRBL_BUFFER)
		LDI XH, HIGH(GRBL_BUFFER)
		
		CALL USB_SEND_D_LINE
		
		POP XH
		POP XL
	
		RJMP CONNECTED_GRBL_PROCESS_LINE_END
	CONNECTED_GRBL_SAVING: 
	
		;A definir
	
	CONNECTED_GRBL_PROCESS_LINE_END:
	
	BUFFER_CLEAR GRBL_BUFFER_POINTER

	RET
	
;Subrutina para procesar una linea de GRBL

.DEF TEMP = R16

CONNECTED_USB_PROCESS_LINE:

	LDS TEMP, GGR

	ANDI TEMP, (1<<CSS) ;Verificar sub estado
	BRNE CONNECTED_USB_SAVING
	
		PUSH XL
		PUSH XH
		
		LDI XL, LOW(USB_BUFFER)
		LDI XH, HIGH(USB_BUFFER)
		
		CALL GRBL_SEND_D_LINE
		
		POP XH
		POP XL
	
		RJMP CONNECTED_USB_PROCESS_LINE_END
	CONNECTED_USB_SAVING: 
	
		;A definir
	
	CONNECTED_USB_PROCESS_LINE_END:
	
	BUFFER_CLEAR USB_BUFFER_POINTER

	RET


;Subrutina para refrescar la interfaz a partir del estado del sistema

.DEF TEMP = R16
.DEF GGR_REG = R18

CONNECTED_REFRESH_UI:
	PUSH GGR_REG
	PUSH ZL
	PUSH ZH

	LDI ZL, LOW(CONSTANT_CONNECTED_TITLE<<1)
	LDI ZH, HIGH(CONSTANT_CONNECTED_TITLE<<1)
	CALL UI_WRITE_FIRST_LINE_P_STRING ;Escribir titulo

	LDI ZL, LOW(CONSTANT_CONNECTED_CANCEL<<1)
	LDI ZH, HIGH(CONSTANT_CONNECTED_CANCEL<<1)
	CALL UI_WRITE_SECOND_LINE_P_STRING ;Escribir primera linea

	LDS GGR_REG, GGR ;Cargar registro de flags
	ANDI GGR_REG, ~(1<<UII) ;Limpiar flag de invalido
	STS GGR, GGR_REG

	POP ZH
	POP ZL
	POP GGR_REG
	RET
