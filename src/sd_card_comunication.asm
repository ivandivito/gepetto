/*
uso:

CALL SD_INIT

para escribir una linea (maximo 254 caracteres para que despues entre en el buffer) 
LDI XL,LOW(TEST)
LDI XH,HIGH(TEST)

CALL SD_TX_LINE

para leerla

CALL SD_RX_LINE
LDI XL,LOW(SD_BUFFER)
LDI XH,HIGH(SD_BUFFER)

tener en cuenta que siempre que se quiera pasar de escritura a lectura o viceversa hay que llamar a CALL SD_END_OP para terminar la opracion actual
*/
.INCLUDE "sd_card_comunication.inc"

.DSEG
SD_BLOCK_POINTER: .BYTE 4
SD_BUFFER: .BYTE BUFFER_SIZE
SD_BUFFER_POINTER: .BYTE 1

.CSEG

;Constantes
.EQU SD_GEPPETO_SIGNATURE_LENGHT = 7
SD_GEPPETO_SIGNATURE:
.DB "GEPPETO", 0x00

;inicializacion de la tarjeta SD
.DEF TEMP = R18
.DEF SD_TX_CMD_RSP = R16
.DEF SD_RX_RSP_REG = R16
SD_INIT:
		
		PUSH TEMP

		CALL SPI_INIT

		BUFFER_CLEAR SD_BUFFER_POINTER

		;reinicio el indice de la SD
		STS SD_BLOCK_POINTER,ZERO_REG
		STS SD_BLOCK_POINTER+1,ZERO_REG
		STS SD_BLOCK_POINTER+2,ZERO_REG
		STS SD_BLOCK_POINTER+3,ZERO_REG

		;activo la SD
		CALL SD_SELECT
		
		;mando muchos clock vacios apraq que se inicialize
		LDI TEMP, 100
	SD_INIT_SD_INIT:
		CALL SPI_RX
		DEC TEMP
		BRNE SD_INIT_SD_INIT

		;reinicio la SD
		SD_TX_CMD_REP_MACRO GO_IDLE_STATE, 0x00000000, SD_CMD_RSP_IDLE

		;reviso version de la SD
	SD_INIT_TX_CMD_IF:
		SD_TX_CMD_MACRO SEND_IF_COND, 0x000001AA, SD_CMD_RSP_IDLE

		CPI SD_TX_CMD_RSP,SD_CMD_RSP_IDLE
		;es V2 inicializacion 
		BREQ SD_INIT_V2

		CPI SD_TX_CMD_RSP,SD_CMD_RSP_INVALID_CMD
		;es V1 inicializacion 
		BREQ SD_INIT_V1 ;si la tajeta no soporta el comando IF (tarjetas viejas) hay que enviar un comando OCR

		;tarjeta no soportada probar de nuevo
		RJMP SD_INIT_SD_INIT

	SD_INIT_V2:
		SD_TX_CMD_MACRO APP_CMD,0x00000000
		SD_TX_CMD_MACRO SD_SEND_OP_COND, 0x40000000
		CPI SD_TX_CMD_RSP, SD_CMD_RSP_NOT_IDLE
		BRNE SD_INIT_V2
		SD_TX_CMD_MACRO READ_OCR, 0x00000000
		CALL SPI_RX
		CALL SPI_RX
		CALL SPI_RX
		RJMP SD_INIT_TX_CMD_LENGHT
		

	SD_INIT_V1:
		SD_TX_CMD_MACRO APP_CMD,0x00000000
		SD_TX_CMD_MACRO SD_SEND_OP_COND, 0x00000000
		CPI SD_TX_CMD_RSP,SD_CMD_RSP_NOT_IDLE
		BRNE SD_INIT_V1	

	SD_INIT_TX_CMD_LENGHT:
		;si la sd es de sectores variables con eso elijo 512
		SD_TX_CMD_MACRO SET_BLOCK_LEN, 0x00000200

		CALL SD_DESELECT

		;se podria aumentar la velocidad aca
		POP TEMP

		RET

;activacion del pin SS de la SD
SD_SELECT:
		
		CBI SPI_PORT,SS_PIN
		RET

;desactivacion del pin SS de la SD
SD_DESELECT:
		
		SBI SPI_PORT,SS_PIN
		RET

;lee por spi hasta que llega a una respuesta distinta a la de espera (FF) y vuelva a llegar FF
.DEF SD_IN_OUT_REG = R16
.DEF SPI_IN_OUT_REG = R16
.DEF SD_RX_RSP_REG = R16
SD_RX_RSP:
		CALL SPI_RX

		CPI SD_IN_OUT_REG,SD_CMD_RSP_WAIT
		BREQ SD_RX_RSP

		MOV SD_RX_RSP_REG,SPI_IN_OUT_REG
		PUSH SD_RX_RSP_REG ;pusheo la respuesta para poder devolvela al final

	SD_RX_WAIT:
		CALL SPI_RX
		CPI SPI_IN_OUT_REG,SD_CMD_RSP_WAIT
		BRNE SD_RX_WAIT

		POP SD_RX_RSP_REG ;recupero la respuesta

		RET

		
;enviar comando a la SD
	.DEF TEMP = R16
	.DEF SPI_IN_OUT_REG = R16
	.DEF SD_TX_CMD_RSP = R16
	.DEF SD_RX_RSP_REG = R16
SD_TX_CMD:
		;mando el comando y sus argumentos
		
		MOV SPI_IN_OUT_REG,SD_CMD_REG
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		ANDI SPI_IN_OUT_REG,0x3F
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF
		CALL SPI_TX
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		MOV SPI_IN_OUT_REG,SD_CMD_ARG_REG_0
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF
		CALL SPI_TX
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		MOV SPI_IN_OUT_REG,SD_CMD_ARG_REG_1
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF
		CALL SPI_TX
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		MOV SPI_IN_OUT_REG,SD_CMD_ARG_REG_2
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF
		CALL SPI_TX
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		MOV SPI_IN_OUT_REG,SD_CMD_ARG_REG_3
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF
		CALL SPI_TX
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		;segun el comando adjunto un final distinto como checksum
		LDI TEMP,SEND_IF_COND
		CP SD_CMD_REG,TEMP
		BREQ SD_TX_SD_CMD_IF_END

		LDI TEMP,SD_CMD_OCR_END
		CP SD_CMD_REG,TEMP
		BREQ SD_TX_SD_CMD_OCR_END

		LDI SPI_IN_OUT_REG, SD_CMD_END
		RJMP SD_TX_SD_CMD_END

	SD_TX_SD_CMD_IF_END:
		LDI SPI_IN_OUT_REG, SD_CMD_IF_END
		RJMP SD_TX_SD_CMD_END

	SD_TX_SD_CMD_OCR_END:
		LDI SPI_IN_OUT_REG, SD_CMD_OCR_END

	SD_TX_SD_CMD_END:
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF
		CALL SPI_TX
		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		LDI R16, 0x00
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		CALL SD_RX_RSP ;leo la respuesta de la SD

		.IFDEF DEBUG_SPI_CMD
		PUSH R16
		PUSH R17
		CALL USB_SEND_CHAR
		POP R17
		POP R16
		.ENDIF

		MOV SD_TX_CMD_RSP,SD_RX_RSP_REG

		RET

;lee una linea del SD y lo escribe en el buffer de SD
.DEF TEMP = R17
.DEF OVERFLOW_REG = R23
.DEF SD_CMD_REG = R2
.DEF SD_TX_CMD_ARG_REG_0 = R3
.DEF SD_TX_CMD_ARG_REG_1 = R4
.DEF SD_TX_CMD_ARG_REG_2 = R5
.DEF SD_TX_CMD_ARG_REG_3 = R6
.DEF SD_BLOCK_POINTER_REG_0 = R19
.DEF SD_BLOCK_POINTER_REG_1 = R20
.DEF SD_BLOCK_POINTER_REG_2 = R21
.DEF SD_BLOCK_POINTER_REG_3 = R22
.DEF SD_RX_RSP_REG = R16
.DEF SPI_IN_OUT_REG = R16
.DEF CHAR_REG = R16
SD_RX_LINE:

		PUSH SD_BLOCK_POINTER_REG_0
		PUSH SD_BLOCK_POINTER_REG_1
		PUSH SD_BLOCK_POINTER_REG_2
		PUSH SD_BLOCK_POINTER_REG_3
		PUSH OVERFLOW_REG

		LDI OVERFLOW_REG,0xFE

		;cargo el puntero de bloque
		
		LDS SD_BLOCK_POINTER_REG_0,SD_BLOCK_POINTER
		LDS SD_BLOCK_POINTER_REG_1,SD_BLOCK_POINTER+1
		LDS SD_BLOCK_POINTER_REG_2,SD_BLOCK_POINTER+2
		LDS SD_BLOCK_POINTER_REG_3,SD_BLOCK_POINTER+3

		;escribo desde el inicio del buffer
		BUFFER_CLEAR SD_BUFFER_POINTER

		CALL SD_SELECT

	SD_RX_LINE_LOOP:

		;se podria agregar un testeo si se llego al final de la memoria disponible

		;reviso si hay que mandar instruccion de lectura (si el numero es multiplo de 512)
		CPI SD_BLOCK_POINTER_REG_3, 0x00
		BRNE SD_RX_LINE_RX

		MOV TEMP,SD_BLOCK_POINTER_REG_2
		ANDI TEMP,0x01
		CPI TEMP,0x00
		BRNE SD_RX_LINE_RX

	SD_RX_LINE_TX_CMD:

		; antes de mandar el sigueinte comando leo los CRC del anterior
		CALL SPI_RX
		CALL SPI_RX
		CALL SPI_RX
		CALL SPI_RX
		CALL SPI_RX
		CALL SPI_RX

		; mando el comando
		LDI TEMP, READ_SINGLE_BLOCK
		MOV SD_CMD_REG, TEMP
		MOV SD_TX_CMD_ARG_REG_0,SD_BLOCK_POINTER_REG_0
		MOV SD_TX_CMD_ARG_REG_1,SD_BLOCK_POINTER_REG_1
		MOV SD_TX_CMD_ARG_REG_2,SD_BLOCK_POINTER_REG_2
		MOV SD_TX_CMD_ARG_REG_3,SD_BLOCK_POINTER_REG_3
		CALL SD_TX_CMD

		CPI SD_RX_RSP_REG,SD_CMD_RSP_NOT_IDLE
		BRNE SD_RX_LINE_TX_CMD

	SD_RX_LINE_TX_WAIT_INIT:
		CALL SPI_RX
		CPI SPI_IN_OUT_REG, SD_CMD_RSP_START
		BRNE SD_RX_LINE_TX_WAIT_INIT

	SD_RX_LINE_RX:

		
		DEC OVERFLOW_REG
		TST OVERFLOW_REG
		BREQ SD_RX_LINE_END_BUFFER

		CALL SPI_RX
		;guardo el caracter
		PUSH SPI_IN_OUT_REG
		;Guardo en el buffer
		MOV CHAR_REG,SPI_IN_OUT_REG
		BUFFER_INSERT_CHAR SD_BUFFER, SD_BUFFER_POINTER
		;aumento puntero de bloques
		LDI TEMP,1
		ADD SD_BLOCK_POINTER_REG_3, TEMP
		ADC SD_BLOCK_POINTER_REG_2,ZERO_REG
		ADC SD_BLOCK_POINTER_REG_1,ZERO_REG
		ADC SD_BLOCK_POINTER_REG_0,ZERO_REG

		;cargo el caracter
		POP SPI_IN_OUT_REG
		CPI SPI_IN_OUT_REG,'\n'
		BREQ SD_RX_LINE_END

		JMP SD_RX_LINE_LOOP

		;si es el ultimo caracter disponible del buffer guardo un \n
	SD_RX_LINE_END_BUFFER:
		LDI CHAR_REG,'\n'
		BUFFER_INSERT_CHAR SD_BUFFER, SD_BUFFER_POINTER

	SD_RX_LINE_END:

		CALL SD_DESELECT

		STS SD_BLOCK_POINTER,SD_BLOCK_POINTER_REG_0
		STS SD_BLOCK_POINTER+1,SD_BLOCK_POINTER_REG_1
		STS SD_BLOCK_POINTER+2,SD_BLOCK_POINTER_REG_2
		STS SD_BLOCK_POINTER+3,SD_BLOCK_POINTER_REG_3
		
		POP OVERFLOW_REG
		POP SD_BLOCK_POINTER_REG_3
		POP SD_BLOCK_POINTER_REG_2
		POP SD_BLOCK_POINTER_REG_1
		POP SD_BLOCK_POINTER_REG_0
		RET

; escribe una linea en la SD apartir de lo apuntado por X
.DEF TEMP = R16
.DEF SD_CMD_REG = R2
.DEF SD_TX_CMD_ARG_REG_0 = R3
.DEF SD_TX_CMD_ARG_REG_1 = R4
.DEF SD_TX_CMD_ARG_REG_2 = R5
.DEF SD_TX_CMD_ARG_REG_3 = R6
.DEF SD_BLOCK_POINTER_REG_0 = R19
.DEF SD_BLOCK_POINTER_REG_1 = R20
.DEF SD_BLOCK_POINTER_REG_2 = R21
.DEF SD_BLOCK_POINTER_REG_3 = R22
.DEF SD_RX_RSP_REG = R16
.DEF SPI_IN_OUT_REG = R16
.DEF CHAR_REG = R16
SD_TX_LINE:

		PUSH SD_BLOCK_POINTER_REG_0
		PUSH SD_BLOCK_POINTER_REG_1
		PUSH SD_BLOCK_POINTER_REG_2
		PUSH SD_BLOCK_POINTER_REG_3

		;cargo el puntero de bloque
		LDS SD_BLOCK_POINTER_REG_0,SD_BLOCK_POINTER
		LDS SD_BLOCK_POINTER_REG_1,SD_BLOCK_POINTER+1
		LDS SD_BLOCK_POINTER_REG_2,SD_BLOCK_POINTER+2
		LDS SD_BLOCK_POINTER_REG_3,SD_BLOCK_POINTER+3


		CALL SD_SELECT

	SD_TX_LINE_LOOP:

		;se podria agregar un testeo si se llego al final de la memoria disponible

		;reviso si hay que mandar instruccion de lectura (si el numero es multiplo de 512)
		CPI SD_BLOCK_POINTER_REG_3,0x00
		BRNE SD_TX_LINE_TX

		MOV TEMP,SD_BLOCK_POINTER_REG_2
		ANDI TEMP,0x01
		CPI TEMP,0x00
		BRNE SD_TX_LINE_TX

	SD_TX_LINE_TX_CMD:
		;escribo el CRC del bloque anterior, si es el primero no pasa nada
		LDI SPI_IN_OUT_REG,SD_CMD_RSP_WAIT
		CALL SPI_TX
		LDI SPI_IN_OUT_REG,SD_CMD_RSP_WAIT
		CALL SPI_TX
		;leo respuesta de la escritura anterior
		CALL SPI_RX

	SD_TX_LINE_TX_CMD_W_1:
		CALL SPI_RX
		CPI SPI_IN_OUT_REG,0x00
		BREQ SD_TX_LINE_TX_CMD_W_1

		; mando el comando
		LDI TEMP, WRITE_SINGLE_BLOCK
		MOV SD_CMD_REG, TEMP
		MOV SD_TX_CMD_ARG_REG_0,SD_BLOCK_POINTER_REG_0
		MOV SD_TX_CMD_ARG_REG_1,SD_BLOCK_POINTER_REG_1
		MOV SD_TX_CMD_ARG_REG_2,SD_BLOCK_POINTER_REG_2
		MOV SD_TX_CMD_ARG_REG_3,SD_BLOCK_POINTER_REG_3
		CALL SD_TX_CMD

		; revisar si escribo primro un FF siempre!!!!! por comprobar que termino respuesta
		
		;revisar respuesta con 0
		CPI SD_RX_RSP_REG,SD_CMD_RSP_NOT_IDLE
		BRNE SD_TX_LINE_TX_CMD

		LDI SPI_IN_OUT_REG,SD_CMD_RSP_START
		CALL SPI_TX

	SD_TX_LINE_TX:

		LD TEMP,X+
		MOV SPI_IN_OUT_REG,TEMP
		PUSH TEMP ; guardo caracter

		CALL SPI_TX

		;aumento puntero de bloques
		LDI TEMP,1
		ADD SD_BLOCK_POINTER_REG_3, TEMP
		ADC SD_BLOCK_POINTER_REG_2,ZERO_REG
		ADC SD_BLOCK_POINTER_REG_1,ZERO_REG
		ADC SD_BLOCK_POINTER_REG_0,ZERO_REG
		
		POP TEMP ; recupero caracter
		CPI TEMP,'\n'
		BREQ SD_TX_LINE_END

		JMP SD_TX_LINE_LOOP

	SD_TX_LINE_END:
		CALL SD_DESELECT

		STS SD_BLOCK_POINTER,SD_BLOCK_POINTER_REG_0
		STS SD_BLOCK_POINTER+1,SD_BLOCK_POINTER_REG_1
		STS SD_BLOCK_POINTER+2,SD_BLOCK_POINTER_REG_2
		STS SD_BLOCK_POINTER+3,SD_BLOCK_POINTER_REG_3

		POP SD_BLOCK_POINTER_REG_3
		POP SD_BLOCK_POINTER_REG_2
		POP SD_BLOCK_POINTER_REG_1
		POP SD_BLOCK_POINTER_REG_0
		
		RET

SD_END_OP:

		PUSH SD_BLOCK_POINTER_REG_0
		PUSH SD_BLOCK_POINTER_REG_1
		PUSH SD_BLOCK_POINTER_REG_2
		PUSH SD_BLOCK_POINTER_REG_3

		;cargo el puntero de bloque
		
		LDS SD_BLOCK_POINTER_REG_0,SD_BLOCK_POINTER
		LDS SD_BLOCK_POINTER_REG_1,SD_BLOCK_POINTER+1
		LDS SD_BLOCK_POINTER_REG_2,SD_BLOCK_POINTER+2
		LDS SD_BLOCK_POINTER_REG_3,SD_BLOCK_POINTER+3

		CALL SD_SELECT

	SD_END_OP_LOOP:

		;reviso si llegue al final de un bloque (si el numero es multiplo de 512)
		CPI SD_BLOCK_POINTER_REG_3,0x00
		BRNE SD_END_OP_RX

		MOV TEMP,SD_BLOCK_POINTER_REG_2
		ANDI TEMP,0x01
		CPI TEMP,0x00
		BRNE SD_END_OP_RX

		JMP SD_END_OP_END

	SD_END_OP_RX:

		LDI R16,0
		CALL SPI_TX

		;aumento puntero de bloques
		LDI TEMP,1
		ADD SD_BLOCK_POINTER_REG_3, TEMP
		ADC SD_BLOCK_POINTER_REG_2,ZERO_REG
		ADC SD_BLOCK_POINTER_REG_1,ZERO_REG
		ADC SD_BLOCK_POINTER_REG_0,ZERO_REG

		RJMP SD_END_OP_LOOP

	SD_END_OP_END:

		;leo o escribo los CRC
		CALL SPI_RX
		CALL SPI_RX
		CALL SPI_RX
		CALL SPI_RX

		CALL SD_DESELECT

		;reinicio el indice de la SD
		STS SD_BLOCK_POINTER,ZERO_REG
		STS SD_BLOCK_POINTER+1,ZERO_REG
		STS SD_BLOCK_POINTER+2,ZERO_REG
		STS SD_BLOCK_POINTER+3,ZERO_REG

		POP SD_BLOCK_POINTER_REG_3
		POP SD_BLOCK_POINTER_REG_2
		POP SD_BLOCK_POINTER_REG_1
		POP SD_BLOCK_POINTER_REG_0
		RET